#!/data/data/com.termux/files/usr/bin/bash
# Advanced Smart File Manager with Multi-Item Operations

handle_file() {
    local file="$1"
    while true; do
        echo
        echo "📄 File selected: $(basename "$file")"
        echo "What would you like to do with the file?"
        echo "1) Open using external tool (termux-open)"
        echo "2) Edit using nano"
        echo "3) Delete file"
        echo "4) Back to browser"
        read -p "Enter choice [1-4]: " action

        case "$action" in
            1)
                termux-open "$file"
                ;;
            2)
                nano "$file"
                ;;
            3)
                rm -i "$file"
                return 1
                ;;
            4)
                return 1
                ;;
            *)
                echo "❌ Invalid option. Try again."
                ;;
        esac
    done
}

get_abs_path() {
    local target="$1"
    if [ -d "$target" ]; then
        cd -- "$target" && pwd
    elif [ -f "$target" ]; then
        local dir=$(dirname -- "$target")
        local base=$(basename -- "$target")
        echo "$(cd -- "$dir" && pwd)/$base"
    else
        echo "Error: '$target' does not exist" >&2
        return 1
    fi
}

create_files() {
    read -p "Enter filenames (separated by |): " filelist
    IFS='|' read -ra files <<< "$filelist"
    for file in "${files[@]}"; do
        touch "$path/$file"
        echo "✅ Created file: $file"
    done
}

create_dirs() {
    read -p "Enter folder names (separated by |): " dirlist
    IFS='|' read -ra dirs <<< "$dirlist"
    for dir in "${dirs[@]}"; do
        mkdir -p "$path/$dir"
        echo "✅ Created folder: $dir"
    done
}

move_items() {
    read -p "Enter item numbers to move (separated by |): " itemlist
    IFS='|' read -ra indices <<< "$itemlist"
    
    # Get destination path
    read -p "Enter destination path: " dest
    dest=$(realpath "$dest" 2>/dev/null || echo "$path/$dest")
    
    if [ ! -d "$dest" ]; then
        echo "❌ Destination does not exist or is not a directory"
        return
    fi

    # Move selected items
    for index in "${indices[@]}"; do
        if [[ $index =~ ^[0-9]+$ ]] && [ $index -ge 1 ] && [ $index -le ${#items[@]} ]; then
            item="${items[$((index-1))]}"
            mv -v "$item" "$dest"
        else
            echo "❌ Invalid index: $index"
        fi
    done
}

# Handle command-line arguments
if [ $# -eq 1 ]; then
    target="$1"
    
    if [ -d "$target" ]; then
        path=$(get_abs_path "$target")
    elif [ -f "$target" ]; then
        selected=$(get_abs_path "$target")
        handle_file "$selected"
        exit $?
    else
        echo "Error: '$target' not found" >&2
        exit 1
    fi
else
    path=$(pwd)
fi

shopt -s nullglob
while true; do
    echo
    echo "📂 Location: $path"
    items=("$path"/*)
    
    if [ ${#items[@]} -eq 0 ]; then
        echo "🛑 This directory is empty"
    else
        idx=1
        for item in "${items[@]}"; do
            if [ -d "$item" ]; then
                icon="📁"
            else
                icon="📄"
            fi
            printf "%2d) %s %s\n" "$idx" "$icon" "$(basename "$item")"
            idx=$((idx+1))
        done
    fi

    echo
    echo "n) New folder    f) New file    u) Up directory"
    echo "c) CD to here    m) Move items  q) Quit"
    read -p "Select item number or command: " choice

    # Handle commands
    case "$choice" in
        q|Q)
            exit 0
            ;;
        u|U)
            [ "$path" != "/" ] && path=$(dirname "$path")
            continue
            ;;
        n|N)
            create_dirs
            continue
            ;;
        f|F)
            create_files
            continue
            ;;
        c|C)
            echo
            echo "📌 Current directory set to:"
            echo "cd '$path'"
            echo "You can now run commands in this directory"
            continue
            ;;
        m|M)
            if [ ${#items[@]} -eq 0 ]; then
                echo "❌ No items to move"
            else
                move_items
            fi
            continue
            ;;
    esac

    # Handle numeric selection
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt "${#items[@]}" ]; then
        echo "⚠️  Invalid selection" >&2
        continue
    fi

    selected="${items[$((choice-1))]}"

    if [ -d "$selected" ]; then
        path="$selected"
    elif [ -f "$selected" ]; then
        handle_file "$selected"
    else
        echo "❓ Unsupported item type" >&2
    fi
done
